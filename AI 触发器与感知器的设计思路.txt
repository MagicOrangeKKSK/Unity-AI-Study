当我们控制角色的时候  会发现有很多问题要去处理 不仅仅是移动
其中最重要的一个问题就是角色如何感知周围的游戏世界
为了让AI角色看上去更加的真实 也有去  那么我们就必须让它能够以正常的感知方式知道周围发生了什么
把比如说 如果玩家丢出了一个瓶子到了怪物的附近 那么它就会检测到瓶子落地的声音 并且去找到扔瓶子的玩家的位置
因此呢 我们需要的首先是一个“感知系统” （sensor）
在游戏中 感知的开销 可能会很大 通常情况下 每个角色都需要查询其他所有角色 
假设游戏里面有n个骑士  n个僵尸  骑士根据看到的僵尸数量来决定自身行为
这个时候 假设对于每个僵尸 需要O(n)时间来确定数量的话
那么对于n个骑士 我们就需要 O(n2)时间
 因此 在许多的情况下 感知不能 也不需要在每帧中进行
AI能感知到的信息是多种多样的 通常包含了 视觉和听觉信息  
我们的AI可以听到脚步声  发现死去的同伴或者敌人
这里我就可以提一嘴warframe 里面的敌人就有听觉系统 和 发现同伴尸体的功能
其中 “视线查询”几乎不可避免（line of sight） 
在unity里面 我们可以使用raycast实现视觉系统
但是问题是它的速度相对较慢
当场景里有大量物体时 或者调用过于频繁时  它会对我们的游戏性能的开销比较大
另外呢 一个AI可能有多种感知器 比如说一个士兵可能有一个战术感知器 用来扫描埋伏点或者好的地点 以便于躲藏或者战斗
有一个环境感知器  用来检测墙壁和障碍 
还有一个感知器 用来感知动态的物体等
 
尤其感知系统涉及到了一些复杂的计算 
因此为了确保游戏的效率 必须确定游戏中到底需要处理哪些信息
不同的游戏需要的感知系统有很大的不同
 
比如对于简单的单人小游戏
可能只需要知道玩家的位置就足够了
而对于潜行类的游戏 
就需要强大的感知系统来提供更好的游戏体验
 
在游戏中AI可以通过两种方式获取游戏世界的信息 
轮询和/或事件驱动
简单的来说呢
轮询就是AI积极地观察世界来获取信息
而事件驱动是通过坐等消息的方式来获得信息

我们可以想一个例子
一个角色使用了一个范围技能 引起了一个区域伤害
大概会影响好几个游戏对象
如果让每个游戏对象周期性地查询是否附近有玩家使用技能
这就是轮询
如果让AOE这个技能告诉每个被它击中的物体 以及被击中的伤害 这就是事件驱动

很显然 如果想知道周围的世界发生了什么
最简单的就是去查询
如果角色想知道周围有没有其他AI角色 
它可以直接在代码中查找所有AI角色看看它们是否在附近
这就是轮询 很好实现 不需要什么特别的架构

但是 当可能感兴趣的事件数量增加的时候
AI角色就要花大量的时间用于查询
并且查询返回的大部分信息都是无用信息
这让我们的调试工作变得困难
一种让基于轮询的感知系统更容易维护的方式就是建立一个轮询中心
在这里进行所有的查询 有的时候采用轮询是最好的选择
例如 如果AI角色想检测玩家是否接近 那么直接 查询玩家的当前位置就可以了
但有些情况下 我们有更好的方式

那么我们接下来介绍一下事件驱动方式
在Unity中  如果想知道附近是否有AI角色
有一种方式可以很容易实现
就是给AI 或者AI的子物体 添加一个大半径的collider
选中isTrigger
当Unity的物理引擎检测到碰撞的时候，就会自动调用OnTriggerEnter函数  这样子只需要在O你TriggerEnter里写出相应的代码就可以了

这种方式我们可以看作是事件驱动的
在事件驱动的感知系统中
有一个中心检测系统
它查找角色感兴趣的事件是否发生
当发生的时候
他会通知每个角色
这可以看作是某种事件传递机制
 
比如说  当场景中突然想起了枪声
那么中心检测系统会检测到它
然后通知枪声附近的所有角色
这些角色再做出相应的反应
 你提到 如果角色都不动 怎么办
这里我们可以用有限状态机或者行为树  设置一个默认状态 或者说是待机状态  比如士兵会巡逻  卖道具的NPC会站在摊位上吆喝  这种状态/行为是不需要外加去触发它的 但这些都是后话 
 
这个中心检测系统我们可以称它为 “事件管理器”
它记录了每个AI角色所感兴趣的事件
并且负责检查，处理和分发事件。
由于条件和检查都是集中完成的
因此采用这种方式可以很方便地进行记录 和 显示相关信息
非常有利于调试
 
至此 我们从刚刚的轮询/事件驱动  感知系统和触发系统的介绍里 可以大概看到一个轮廓
物体具有触发器  比如说瓶子掉地上会有一个声音触发器
那么声音触发器 触发了 通知 事件管理器
事件管理器 查询附近有哪些听觉感知器
然后通知听觉感知器 这里有瓶子摔碎了
触发器 --(触发)-> 事件管理 --（分发）->感知器
这样一个简单的模型 就诞生了
那么 这也是 第九章/第十章课的核心设计思路
好了 下课
